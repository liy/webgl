<!DOCTYPE html>
<html>
<head>
<title>cube</title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script id='vshader' type="x-shader/x-vertex">
attribute vec3 a_position;
attribute vec4 a_color;

uniform mat4 u_pMatrix;
uniform mat4 u_mvMatrix;
uniform mat4 u_cMatrix;

varying vec4 v_color;

void main(){
  gl_Position = u_pMatrix * u_cMatrix * u_mvMatrix * vec4(a_position, 1);
  v_color = a_color;
}
</script>
<script id='fshader' type="x-shader/x-fragment">
precision mediump float;
varying vec4 v_color;

void main(){
  gl_FragColor = v_color;
}
</script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
// gl.enable(gl.FACE_CULL);
gl.clearColor(0, 0, 0, 1);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

// shaders
var vshader = compileShader(gl, document.getElementById('vshader').textContent, gl.VERTEX_SHADER);
var fshader = compileShader(gl, document.getElementById('fshader').textContent, gl.FRAGMENT_SHADER);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

// locations
var positionLocation = gl.getAttribLocation(program, 'a_position');
var colorLocation = gl.getAttribLocation(program, 'a_color');
var pMatrixLocation = gl.getUniformLocation(program, 'u_pMatrix');
var mvMatrixLocation = gl.getUniformLocation(program, 'u_mvMatrix');
var cMatrixLocation = gl.getUniformLocation(program, 'u_cMatrix');

// vertices
var vertices = [
  // front
  -0.5,  0.5,  0.5,
  -0.5, -0.5,  0.5,
   0.5, -0.5,  0.5,
   0.5,  0.5,  0.5,
  // back
   0.5,  0.5, -0.5,
   0.5, -0.5, -0.5,
  -0.5, -0.5, -0.5,
  -0.5,  0.5, -0.5,
  // top
  -0.5,  0.5, -0.5,
  -0.5,  0.5,  0.5,
   0.5,  0.5,  0.5,
   0.5,  0.5, -0.5, 
  // bottom
  -0.5, -0.5,  0.5,
  -0.5, -0.5, -0.5,
   0.5, -0.5, -0.5,
   0.5, -0.5,  0.5,
  // left
  -0.5,  0.5, -0.5,
  -0.5, -0.5, -0.5,
  -0.5, -0.5,  0.5,
  -0.5,  0.5,  0.5,
  // right
   0.5,  0.5,  0.5,
   0.5, -0.5,  0.5,
   0.5, -0.5, -0.5,
   0.5,  0.5, -0.5
];

// colour
var packedColours = [
  [1.0, 0.0, 0.0, 1.0], // front, red
  [0.0, 1.0, 0.0, 1.0], // back, green
  [0.0, 0.0, 1.0, 1.0], // top, blue
  [1.0, 1.0, 0.0, 1.0], // bottom, yellow?
  [1.0, 0.0, 1.0, 1.0], // left
  [1.0, 0.5, 0.5, 1.0], // right
];
var colours = [];
for(var i=0; i<packedColours.length; ++i){
  var colour = packedColours[i];
  // assign to 4 vertices
  for(var j=0; j<4; ++j){
    colours = colours.concat(colour);
  }
}

// indices
var indices = [
  0,  1,  2,   0,  2,  3,  // front
  4,  5,  6,   4,  6,  7,  // back
  8,  9,  10,  8,  10, 11, // top
  12, 13, 14,  12, 14, 15, // bottom
  16, 17, 18,  16, 18, 19,  // left
  20, 21, 22,  20, 22, 23// right
];

// vertex buffer
var vb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(positionLocation);

// color buffer
var cb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);
gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(colorLocation);

// indices buffer
var ib = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

// projection matrix
var pMatrix = mat4.create();
mat4.perspective(pMatrix, Math.PI/3, canvas.width/canvas.height, 1, 500);
// false, do not transpose the projection matrix
gl.uniformMatrix4fv(pMatrixLocation, false, pMatrix);

// model view matrix
var mvMatrix = mat4.create();

// camera matrix
var cMatrix = mat4.create();
var velocity = vec3.create();

var targetRotationY = 0;
var targetRotationX = 0;
var rotationX = 0;
var rotationY = 0;
function render(){
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  rotationX += (targetRotationX - rotationX)/10;
  rotationY += (targetRotationY - rotationY)/10;
  // update model view matrix
  mat4.identity(mvMatrix);
  mat4.translate(mvMatrix, mvMatrix, [0, 0, -5]);
  mat4.rotate(mvMatrix, mvMatrix, rotationY, [0, 1, 0]);
  mat4.rotate(mvMatrix, mvMatrix, rotationX, [1, 0, 0]);

  vec3.set(velocity, vx, vy, vz);
  mat4.translate(cMatrix, cMatrix, velocity);

  gl.uniformMatrix4fv(mvMatrixLocation, false, mvMatrix);
  gl.uniformMatrix4fv(cMatrixLocation, false, cMatrix);

  // draw, start from index 0
  gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

  requestAnimFrame(render);
}
requestAnimFrame(render);

document.onmousemove = function(evt){
  targetRotationX = -evt.y/window.innerHeight * Math.PI*2;
  targetRotationY = evt.x/window.innerWidth * Math.PI*2;
}


var vx = 0;
var vy = 0;
var vz = 0;
document.addEventListener('keydown', function(evt){
  // console.log(evt.keyCode);
  switch(evt.keyCode){
    // right
    case 39:
      vx = 0.01;
    break;
  }
});

document.addEventListener('keyup', function(evt){
  // console.log(evt.keyCode);
  switch(evt.keyCode){
    // right
    case 39:
      vx = 0;
    break;
  }
});

</script>
</body>
</html>