<!DOCTYPE html>
<html>
<head>
<title></title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script src='../lib/Loader.js'></script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var vshader;
var fshader;
var loader = new Loader();
loader.load('default.vert', function(e){
  vshader = compileShader(gl, this.data, gl.VERTEX_SHADER);
}, false);
loader.load('default.frag', function(e){
  fshader = compileShader(gl, this.data, gl.FRAGMENT_SHADER);
}, false);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

// sphere
// variables
var vertices = [];
var indices = [];
var texCoord = [];
var normals = [];

// sphere
var axialTilt = -23.439 * Math.PI/180;
var latitudeBands = 40;
var longitudeBands = 40;
var radius = 2;
var theta = Math.PI/2;
var phi = Math.PI/2;
var x = 0;
var y = 0;
var z = 0;
for(var i=0; i<=latitudeBands; ++i){
  theta = Math.PI/2 - i * (Math.PI/latitudeBands);
  cosTheta = Math.cos(theta);
  sinTheta = Math.sin(theta);
  for(var j=0; j<=longitudeBands; ++j){
    phi = j * (Math.PI*2 / longitudeBands);
    
    x = cosTheta * Math.cos(phi);
    y = sinTheta;
    z = cosTheta * Math.sin(phi);

    // normals
    normals.push(x);
    normals.push(y);
    normals.push(z);

    vertices.push(x * radius);
    vertices.push(y * radius);
    vertices.push(z * radius);

    texCoord.push(1 - j/longitudeBands);
    texCoord.push(i/latitudeBands);
  }
}
// indices
for(var i=0; i<latitudeBands; ++i){
  for(var j=0; j<longitudeBands; ++j){
    var topLeft = i * longitudeBands + i + j;
    var bottomLeft = topLeft + longitudeBands + 1;

    indices.push(topLeft);
    indices.push(bottomLeft);
    indices.push(bottomLeft + 1);
    indices.push(bottomLeft + 1);
    indices.push(topLeft + 1);
    indices.push(topLeft);
  }
}

var vertexLocation = gl.getAttribLocation(program, 'a_Vertex');
var normalLocation = gl.getAttribLocation(program, 'a_Normal');
var texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
// matrix
var projectionMatrixLocation = gl.getUniformLocation(program, 'u_ProjectionMatrix');
var modelViewMatrixLocation = gl.getUniformLocation(program, 'u_ModelViewMatrix');
var normalMatrixLocation = gl.getUniformLocation(program, 'u_NormalMatrix');
// light
var lightPositionLocation = gl.getUniformLocation(program, 'u_Light.position');
var lightAmbientLocation = gl.getUniformLocation(program, 'u_Light.ambient');
var lightDiffuseLocation = gl.getUniformLocation(program, 'u_Light.diffuse');
var lightSpecularLocation = gl.getUniformLocation(program, 'u_Light.specular');
var attenuationConstantLocation = gl.getUniformLocation(program, 'u_Light.attenuationConstant');
var attenuationLinearLocation = gl.getUniformLocation(program, 'u_Light.attenuationLinear');
var attenuationQuadraticLocation = gl.getUniformLocation(program, 'u_Light.attenuationQuadratic');
var spotDirectionLocation = gl.getUniformLocation(program, 'u_Light.direction');
var spotCosOuterLocation = gl.getUniformLocation(program, 'u_Light.cosOuter');
var spotCosFalloffLocation = gl.getUniformLocation(program, 'u_Light.cosFalloff');
// material
var materialPositionLocation = gl.getUniformLocation(program, 'u_Material.position');
var materialAmbientLocation = gl.getUniformLocation(program, 'u_Material.ambient');
var materialDiffuseLocation = gl.getUniformLocation(program, 'u_Material.diffuse');
var materialSpecularLocation = gl.getUniformLocation(program, 'u_Material.specular');
var materialEmissionLocation = gl.getUniformLocation(program, 'u_Material.emission');
var materialShininessLocation = gl.getUniformLocation(program, 'u_Material.shininess');

// light
gl.uniform4fv(lightAmbientLocation, [0.3, 0.3, 0.3, 1.0]);
gl.uniform4fv(lightDiffuseLocation, [0.5, 0.5, 0.5, 1.0]);
gl.uniform4fv(lightSpecularLocation, [0.9, 0.9, 0.9, 1.0]);
gl.uniform1f(attenuationConstantLocation, 0.1);
gl.uniform1f(attenuationLinearLocation, 0.1);
gl.uniform1f(attenuationQuadraticLocation, 0.1);
gl.uniform1f(spotCosOuterLocation, Math.cos(Math.PI/6));
gl.uniform1f(spotCosFalloffLocation, Math.cos(Math.PI/6) - Math.cos(Math.PI/9));
// material
gl.uniform4fv(materialAmbientLocation, [0.9, 0.9, 0.9, 1.0]);
gl.uniform4fv(materialDiffuseLocation, [0.8, 0.8, 0.8, 1.0]);
gl.uniform4fv(materialSpecularLocation, [1.0, 1.0, 1.0, 1.0]);
gl.uniform4fv(materialEmissionLocation, [0.0, 0.0, 0.0, 0.0]);
gl.uniform1f(materialShininessLocation, 50);


// vertex buffer
var vb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.vertexAttribPointer(vertexLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(vertexLocation);

// texture buffer
var tb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, tb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoord), gl.STATIC_DRAW);
gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(texCoordLocation);

// normal buffer
var nb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, nb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, gl.FLOAT, 0, 0);
gl.enableVertexAttribArray(normalLocation);

// indices buffer
var ib = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

// matrix
var modelViewMatrix = mat4.create();
var projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, Math.PI/3, canvas.width/canvas.height, 0.1, 300);
var lightMatrix = mat4.create();
var normalMatrix = mat3.create();

gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);


var lightRotationY = 0;
var lightPosition = vec3.create();
var spotDirection = vec3.create();
var earthPosition = vec3.fromValues(0, 0, -5);

var image = createImage('../img/earth-big.jpg', init);
function init(){
  // texture
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.generateMipmap(gl.TEXTURE_2D);
  
  function render(){
    gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
    
    mat4.identity(modelViewMatrix);
    mat4.translate(modelViewMatrix, modelViewMatrix, earthPosition);
    gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

    // setup normal matrix
    gl.uniformMatrix3fv(normalMatrixLocation, false, mat3.normalFromMat4(normalMatrix, modelViewMatrix));
    

    // rotate light
    lightRotationY -= 0.01;
    mat4.identity(lightMatrix);
    mat4.translate(lightMatrix, lightMatrix, [0.0, 0.0, -5.0]);
    mat4.rotateY(lightMatrix, lightMatrix, lightRotationY);
    mat4.translate(lightMatrix, lightMatrix, [0.0, 0.0, -3]);

    // transform light position
    vec3.set(lightPosition, 0.0, 0.0, 0.0);
    vec3.transformMat4(lightPosition, lightPosition, lightMatrix);

    // set light position and direction
    mat4.identity(lightMatrix);
    gl.uniform3fv(lightPositionLocation, lightPosition);
    
    vec3.sub(spotDirection, earthPosition, lightPosition);
    gl.uniform3fv(spotDirectionLocation, spotDirection);

    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    
    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}


</script>
</body>
</html>