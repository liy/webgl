<html>
<head>
<title></title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script src='../lib/ShaderLoader.js'></script>
<script src='../lib/Shader.js'></script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var postProgram = gl.createProgram();
var preProgram = gl.createProgram();
var preShader = new Shader(preProgram, 'pre.vert', 'pre.frag');
var postShader = new Shader(postProgram, 'post.vert', 'post.frag');

var framebufferWidth = canvas.width/5;
var framebufferHeight = canvas.height/5;

var kernel = [
  0, 0, 0,
  0, 1, 0,
  0, 0, 0
];

var modelViewMatrix = mat4.create();
var projectionMatrix = mat4.create();
var normalMatrix = mat3.create();
var lightMatrix = mat4.create();

var lightPosition = vec4.create();
vec4.set(lightPosition, 0, 0, 0, 1)
mat4.translate(lightMatrix, lightMatrix, [0.0, 2, -5]);
lightPosition = vec4.transformMat4(lightPosition, lightPosition, lightMatrix);


var cubeRotationX = 0;
var cubeRotationY = 0;
// the cube in the scene.
var cubeVertexBuffer;
var cubeIndexBuffer;
function initCube(x, y, z){
  var vertices = [
    // x y z   u v  nx ny nz
    // front
    -x, -y,  z,   0.0, 1.0,    0,  0,  1,
     x, -y,  z,   1.0, 1.0,    0,  0,  1,
     x,  y,  z,   1.0, 0.0,    0,  0,  1,
    -x,  y,  z,   0.0, 0.0,    0,  0,  1,
    // back
     x, -y, -z,   0.0, 1.0,    0,  0, -1,
    -x, -y, -z,   1.0, 1.0,    0,  0, -1,
    -x,  y, -z,   1.0, 0.0,    0,  0, -1,
     x,  y, -z,   0.0, 0.0,    0,  0, -1,
    // top
    -x,  y,  z,   0.0, 1.0,    0,  1,  0,
     x,  y,  z,   1.0, 1.0,    0,  1,  0,
     x,  y, -z,   1.0, 0.0,    0,  1,  0,
    -x,  y, -z,   0.0, 0.0,    0,  1,  0, 
    // bottom
    -x, -y, -z,   0.0, 1.0,    0, -1,  0,   
     x, -y, -z,   1.0, 1.0,    0, -1,  0,
     x, -y,  z,   1.0, 0.0,    0, -1,  0,
    -x, -y,  z,   0.0, 0.0,    0, -1,  0,
    // left
    -x, -y, -z,   0.0, 1.0,   -1,  0,  0,
    -x, -y,  z,   1.0, 1.0,   -1,  0,  0,
    -x,  y,  z,   1.0, 0.0,   -1,  0,  0,
    -x,  y, -z,   0.0, 0.0,   -1,  0,  0,
    // right
     x, -y,  z,   0.0, 1.0,    1,  0,  0,   
     x, -y, -z,   1.0, 1.0,    1,  0,  0,
     x,  y, -z,   1.0, 0.0,    1,  0,  0,
     x,  y,  z,   0.0, 0.0,    1,  0,  0
  ];

  var indices = [
    0,  1,  2,   0,  2,  3,  // front
    4,  5,  6,   4,  6,  7,  // back
    8,  9,  10,  8,  10, 11, // top
    12, 13, 14,  12, 14, 15, // bottom
    16, 17, 18,  16, 18, 19, // left
    20, 21, 22,  20, 22, 23  // right
  ];

  cubeVertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  cubeIndexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
}

// post processing canvas
var canvasVertexBuffer;
var canvasIndexBuffer;
function initCanvas(x, y, z){
  var vertices = [
    // x y z   u v 
    // front
    -x, -y,  z,   0.0, 1.0,
     x, -y,  z,   1.0, 1.0,
     x,  y,  z,   1.0, 0.0,
    -x,  y,  z,   0.0, 0.0
  ];

  var indices = [
    0,  1,  2,   0,  2,  3,  // front
  ];

  canvasVertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, canvasVertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  canvasIndexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
}

// off screen rendering to frame buffer.
var framebuffer;
var colorTexture;
function initFramebuffer(){
  // create empty color texture associate to frame buffer, store the color information
  colorTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, colorTexture);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, framebufferWidth, framebufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

  // create depth render buffer stores the depth information.
  var depthRenderbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, framebufferWidth, framebufferHeight);

  // create frame buffer. Attach color texture and depth render buffer to the frame buffer
  framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderbuffer);

  // reset to default
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
}

var imageTexture;
function initImageTexture(img){
  imageTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, imageTexture);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

var image = createImage('../img/block.png', init)
function init(){
  initImageTexture(image);
  initFramebuffer();
  initCube(1, 1, 1);
  initCanvas(1, 1, -1);

  function render(){
    preRendering();
    postRendering();

    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}

function preRendering(){
  // render to frame buffer
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  gl.viewport(0, 0, framebufferWidth, framebufferHeight);
  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

  // link program
  gl.useProgram(preProgram);
  preShader.bindAttributes(preProgram);
  preShader.bindUniforms(preProgram);

  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
  gl.bindTexture(gl.TEXTURE_2D, imageTexture);

  // enable vertex pointer ect.
  gl.vertexAttribPointer(preShader.attribute.a_Vertex, 3, gl.FLOAT, false, 32, 0);
  gl.vertexAttribPointer(preShader.attribute.a_TexCoord, 2, gl.FLOAT, false, 32, 12);
  gl.vertexAttribPointer(preShader.attribute.a_Normal, 3, gl.FLOAT, false, 32, 20);
  gl.enableVertexAttribArray(preShader.attribute.a_Vertex);
  gl.enableVertexAttribArray(preShader.attribute.a_TexCoord);
  gl.enableVertexAttribArray(preShader.attribute.a_Normal);

  cubeRotationX += 0.002;
  cubeRotationY -= 0.003;
  mat4.identity(modelViewMatrix);
  mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -5]);
  mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotationX, [1, 0, 0]);
  mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotationY, [0, 1, 0]);
  mat4.perspective(projectionMatrix, Math.PI/3, canvas.width/canvas.height, 0.1, 400);
  gl.uniformMatrix4fv(preShader.uniform['u_ProjectionMatrix'], false, projectionMatrix);
  gl.uniformMatrix4fv(preShader.uniform['u_ModelViewMatrix'], false, modelViewMatrix);

  // light
  gl.uniform4fv(preShader.uniform['u_Light.position'], lightPosition);
  gl.uniform4fv(preShader.uniform['u_Light.ambient'], [0.05, 0.05, 0.05, 1.0]);
  gl.uniform4fv(preShader.uniform['u_Light.diffuse'], [0.4, 0.4, 0.4, 1.0]);
  gl.uniform4fv(preShader.uniform['u_Light.specular'], [1.0, 1.0, 1.0, 1.0]);
  gl.uniform1f(preShader.uniform['u_Light.attenuationConstant'], 1);
  gl.uniform1f(preShader.uniform['u_Light.attenuationLinear'], 0);
  gl.uniform1f(preShader.uniform['u_Light.attenuationQuadratic'], 0);
  gl.uniform3fv(preShader.uniform['u_Light.spotDirection'], [0, 0.5, 0.5]);
  gl.uniform1f(preShader.uniform['u_Light.cosOuter'], Math.cos(Math.PI/3));
  gl.uniform1f(preShader.uniform['u_Light.cosFalloff'], Math.cos(Math.PI/3) - Math.cos(Math.PI/6));
  // material
  gl.uniform4fv(preShader.uniform['u_Material.ambient'], [1.0, 1.0, 1.0, 1.0]);
  gl.uniform4fv(preShader.uniform['u_Material.diffuse'], [1.0, 1.0, 1.0, 1.0]);
  gl.uniform4fv(preShader.uniform['u_Material.specular'], [1.0, 1.0, 1.0, 1.0]);
  gl.uniform4fv(preShader.uniform['u_Material.emission'], [0.0, 0.0, 0.0, 1.0]);
  gl.uniform1f(preShader.uniform['u_Material.shininess'], 50);

  // transform model normal
  mat3.normalFromMat4(normalMatrix, modelViewMatrix);
  gl.uniformMatrix3fv(preShader.uniform['u_NormalMatrix'], false, normalMatrix);

  gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
}

function postRendering(){
  // render to screen canvas context
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

  gl.useProgram(postProgram);
  postShader.bindAttributes(postProgram);
  postShader.bindUniforms(postProgram);

  gl.bindBuffer(gl.ARRAY_BUFFER, canvasVertexBuffer);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
  gl.bindTexture(gl.TEXTURE_2D, colorTexture);

  gl.vertexAttribPointer(postShader.attribute['a_Vertex'], 3, gl.FLOAT, false, 20, 0);
  gl.vertexAttribPointer(postShader.attribute['a_TexCoord'], 2, gl.FLOAT, false, 20, 12);
  gl.enableVertexAttribArray(postShader.attribute['a_Vertex']);
  gl.enableVertexAttribArray(postShader.attribute['a_TexCoord']);

  // Notice that I flip the bottom and top
  mat4.ortho(projectionMatrix, -1, 1, 1, -1, 0.1, 100);
  mat4.identity(modelViewMatrix);
  mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -1]);

  gl.uniformMatrix4fv(postShader.uniform['u_ProjectionMatrix'], false, projectionMatrix);
  gl.uniformMatrix4fv(postShader.uniform['u_ModelViewMatrix'], false, modelViewMatrix);
  gl.uniform2fv(postShader.uniform['u_CanvasSize'], [canvas.width, canvas.height]);
  gl.uniform1fv(postShader.uniform['u_Kernel'], kernel);


  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}

</script>
</body>
</html>