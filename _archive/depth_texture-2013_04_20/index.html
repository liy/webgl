<html>
<head>
<title></title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script src='../lib/ShaderLoader.js'></script>
<script src='../lib/Shader.js'></script>
<script src='LambertianMaterial.js'></script>
<script src='Point.js'></script>
<script src='Plane.js'></script>
<script src='Cube.js'></script>
<script src='Light.js'></script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.1, 0.1, 0.1, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var sceneProgram = gl.createProgram();
var sceneShader = new Shader(sceneProgram, 'lambertian.vert', 'lambertian.frag');
// the depth texture drawing shader
var depthProgram = gl.createProgram();
var depthShader = new Shader(depthProgram, 'depth.vert', 'depth.frag');
// just draw shadow map texture on to the screen for debug
var shadowMapProgram = gl.createProgram();
var shadowMapShader = new Shader(shadowMapProgram, 'shadow_map.vert', 'shadow_map.frag');

var projectionMatrix = mat4.create();

var light = new Light([0, 0, 0, 1]);
light.direction = [0, 0, -1];
var spotOuter = Math.PI/5;
light.cosOuter = Math.cos(spotOuter);
light.cosFalloff = light.cosOuter - Math.cos(Math.PI/7);
light.attenuation = [1.1, 0, 0];

var depthTextureExt = depthTextureExt = gl.getExtension("WEBKIT_WEBGL_depth_texture");


var size = 2048;
var kernel = [
  0, 0, 0,
  0, 1, 0,
  0, 0, 0
];
var colorTexture;
function createColorTexture(){
  colorTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, colorTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
}

var depthTexture;
function createDepthTexture(){
  depthTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, depthTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
}

var framebuffer;
function createFramebuffer(){
  framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
}

var texture;
function initTexture(img){
  texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

var cube;
function initCube(){
  cube = new Cube(1, 1, 1);
  cube.texture = texture;
  cube.position = [0, 0, -2];
}

var plane;
function initPlane(){
  plane = new Plane(10, 10);
  plane.texture = texture;
  plane.position = [0, 0, -4];
  plane.rotationX = -Math.PI/18;
  // plane.rotationY = -Math.PI/8;
}

var modelViewMatrix = mat4.create();
var projectionMatrix = mat4.create();

// post processing canvas
var canvasVertexBuffer;
var canvasIndexBuffer;
function initCanvas(x, y, z){
  var vertices = [
    // x y z   u v 
    // front
    -x, -y,  z,   0.0, 1.0,
     x, -y,  z,   1.0, 1.0,
     x,  y,  z,   1.0, 0.0,
    -x,  y,  z,   0.0, 0.0
  ];

  var indices = [
    0,  1,  2,   0,  2,  3,  // front
  ];

  canvasVertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, canvasVertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  canvasIndexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
}

var image = createImage('../img/square.png', init)
function init(){
  initTexture(image);
  
  initCanvas(1, 1, -1);

  createDepthTexture();
  createColorTexture();
  createFramebuffer();

  initCube();
  initPlane();

  function render(){
    depthRendering();
    renderShadowMap();

    // normal rendering using shadow map texture
    rendering();

    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}

// draw shadow map texture
function depthRendering(){
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  gl.viewport(0, 0, size, size);
  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

  // link sceneProgram
  gl.useProgram(sceneProgram);
  sceneShader.bindAttributes(sceneProgram);
  sceneShader.bindUniforms(sceneProgram);

  // projection
  mat4.perspective(projectionMatrix, spotOuter*2, canvas.width/canvas.height, 0.1, 400);
  gl.uniformMatrix4fv(sceneShader.uniform['u_ProjectionMatrix'], false, projectionMatrix);

  cube.draw(sceneShader, light);

  plane.draw(sceneShader, light);

  light.draw(sceneShader);
}

// debug shadow map
function renderShadowMap(){
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

  gl.useProgram(shadowMapProgram);
  shadowMapShader.bindAttributes(shadowMapProgram);
  shadowMapShader.bindUniforms(shadowMapProgram);

  gl.bindBuffer(gl.ARRAY_BUFFER, canvasVertexBuffer);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, canvasIndexBuffer);
  gl.bindTexture(gl.TEXTURE_2D, depthTexture);
  // gl.bindTexture(gl.TEXTURE_2D, colorTexture);

  gl.vertexAttribPointer(shadowMapShader.attribute['a_Vertex'], 3, gl.FLOAT, false, 20, 0);
  gl.vertexAttribPointer(shadowMapShader.attribute['a_TexCoord'], 2, gl.FLOAT, false, 20, 12);
  gl.enableVertexAttribArray(shadowMapShader.attribute['a_Vertex']);
  gl.enableVertexAttribArray(shadowMapShader.attribute['a_TexCoord']);

  // Notice that I flip the bottom and top
  mat4.ortho(projectionMatrix, -1, 1, 1, -1, 0.1, 100);
  mat4.identity(modelViewMatrix);
  mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -1]);

  gl.uniformMatrix4fv(shadowMapShader.uniform['u_ProjectionMatrix'], false, projectionMatrix);
  gl.uniformMatrix4fv(shadowMapShader.uniform['u_ModelViewMatrix'], false, modelViewMatrix);
  gl.uniform2fv(shadowMapShader.uniform['u_CanvasSize'], [canvas.width, canvas.height]);
  gl.uniform1fv(shadowMapShader.uniform['u_Kernel'], kernel);


  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}

function rendering(){

}

</script>
</body>
</html>