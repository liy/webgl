<!DOCTYPE html>
<html>
<head>
<title>flat shading</title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script src='Loader.js'></script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var vshader;
var fshader;
var loader = new Loader();
loader.load('default.vert', function(e){
  vshader = compileShader(gl, this.data, gl.VERTEX_SHADER);
}, false);
loader.load('default.frag', function(e){
  fshader = compileShader(gl, this.data, gl.FRAGMENT_SHADER);
}, false);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

// sphere
// variables
var vertices = [];
var indices = [];
var texCoord = [];
var normals = [];

// sphere
var axialTilt = -23.439 * Math.PI/180;
var latitudeBands = 40;
var longitudeBands = 40;
var radius = 2;
var theta = Math.PI/2;
var phi = Math.PI/2;
var x = 0;
var y = 0;
var z = 0;
for(var i=0; i<=latitudeBands; ++i){
  theta = Math.PI/2 - i * (Math.PI/latitudeBands);
  cosTheta = Math.cos(theta);
  sinTheta = Math.sin(theta);
  for(var j=0; j<=longitudeBands; ++j){
    phi = j * (Math.PI*2 / longitudeBands);
    
    x = cosTheta * Math.cos(phi);
    y = sinTheta;
    z = cosTheta * Math.sin(phi);

    // normals
    normals.push(x);
    normals.push(y);
    normals.push(z);

    vertices.push(x * radius);
    vertices.push(y * radius);
    vertices.push(z * radius);

    texCoord.push(1 - j/longitudeBands);
    texCoord.push(i/latitudeBands);
  }
}
// indices
for(var i=0; i<latitudeBands; ++i){
  for(var j=0; j<longitudeBands; ++j){
    var topLeft = i * longitudeBands + i + j;
    var bottomLeft = topLeft + longitudeBands + 1;

    indices.push(topLeft);
    indices.push(bottomLeft);
    indices.push(bottomLeft + 1);
    indices.push(bottomLeft + 1);
    indices.push(topLeft + 1);
    indices.push(topLeft);
  }
}

// attributes
var vertexLocation = gl.getAttribLocation(program, 'a_Vertex');
var normalLocation = gl.getAttribLocation(program, 'a_Normal');
var texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
// matrix
var projectionMatrixLocation = gl.getUniformLocation(program, 'u_ProjectionMatrix');
var modelViewMatrixLocation = gl.getUniformLocation(program, 'u_ModelViewMatrix');
var normalMatrixLocation = gl.getUniformLocation(program, 'u_NormalMatrix');
// light matrix
var lightMatrixLocation = gl.getUniformLocation(program, 'u_LightMatrix');
// phong model
// light
var lightPositionLocation = gl.getUniformLocation(program, 'u_Light.position');
var lightAmbientLocation = gl.getUniformLocation(program, 'u_Light.ambient');
var lightDiffuseLocation = gl.getUniformLocation(program, 'u_Light.diffuse');
var lightSpecularLocation = gl.getUniformLocation(program, 'u_Light.specular');
var lightSpotDirectionLocation = gl.getUniformLocation(program, 'u_Light.spotDirection');
var lightSpotCutOffCosLocation = gl.getUniformLocation(program, 'u_Light.spotCutOffCos');
var attenuationConstantLocation = gl.getUniformLocation(program, 'u_Light.attenuationConstant');
var attenuationLinearLocation = gl.getUniformLocation(program, 'u_Light.attenuationLinear');
var attenuationQuadraticLocation = gl.getUniformLocation(program, 'u_Light.attenuationQuadratic');
// material
var materialAmbientLocation = gl.getUniformLocation(program, 'u_Material.ambient');
var materialDiffuseLocation = gl.getUniformLocation(program, 'u_Material.diffuse');
var materialSpecularLocation = gl.getUniformLocation(program, 'u_Material.specular');
var emissionLocation = gl.getUniformLocation(program, 'u_Material.emission');
var shininessLocation = gl.getUniformLocation(program, 'u_Material.shininess');


// setup phong model
// position
var lightPosition = vec3.fromValues(0.0, 0.0, 0.0);
gl.uniform3fv(lightPositionLocation, lightPosition);
// light source
gl.uniform4fv(lightAmbientLocation, [0.08, 0.08, 0.08, 1.0]);
gl.uniform4fv(lightDiffuseLocation, [0.9, 0.9, 0.9, 1.0]);
gl.uniform4fv(lightSpecularLocation, [1.0, 1.0, 1.0, 1.0]);
gl.uniform1f(lightSpotCutOffCosLocation, Math.cos(Math.PI/8));


// material
gl.uniform4fv(materialAmbientLocation, [0.9, 0.9, 0.9, 1.0]);
gl.uniform4fv(materialDiffuseLocation, [0.8, 0.8, 0.8, 1.0]);
gl.uniform4fv(materialSpecularLocation, [1.0, 1.0, 1.0, 1.0]);
// emission
gl.uniform4fv(emissionLocation, [0.0, 0.02, 0.05, 1.0]);
// shininess
gl.uniform1f(shininessLocation, 50);
// distance attenuation
gl.uniform1f(attenuationConstantLocation, 0.1);
gl.uniform1f(attenuationLinearLocation, 0.1);
gl.uniform1f(attenuationQuadraticLocation, 0.1);

// setup buffer
// matrix
var projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, Math.PI/3, canvas.width/canvas.height, 0.1, 800);
gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
var modelViewMatrix = mat4.create();
var normalMatrix = mat3.create();
// light matrix
var lightMatrix = mat4.create();

// vertex buffer
var vb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.vertexAttribPointer(vertexLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(vertexLocation);
// texture buffer
var tb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, tb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoord), gl.STATIC_DRAW);
gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(texCoordLocation);
// normal buffer
var nb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, nb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(normalLocation);
// indices buffer
var ib = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

// load texture
var image = createImage('../img/earth-big.jpg', init);
var rotationY = 0;
var lightRotationY = 0.015;

var spotDirection = vec3.create();
var spherePosition = vec3.fromValues(0, 3, -8);

function init(){
  // texture
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.generateMipmap(gl.TEXTURE_2D);
  
  function render(){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    rotationY += 0.01;
    mat4.identity(modelViewMatrix);
    mat4.translate(modelViewMatrix, modelViewMatrix, spherePosition);
    mat4.rotateZ(modelViewMatrix, modelViewMatrix, axialTilt);
    mat4.rotateY(modelViewMatrix, modelViewMatrix, rotationY);
    gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);


    // update inverse model view matrix
    mat3.normalFromMat4(normalMatrix, modelViewMatrix);
    gl.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix);

    // transform light
    lightRotationY -= 0.01;
    mat4.identity(lightMatrix);
    mat4.translate(lightMatrix, lightMatrix, [0.0, 0.0, -5.0]);
    mat4.rotateY(lightMatrix, lightMatrix, lightRotationY);
    mat4.translate(lightMatrix, lightMatrix, [0.0, 0.0, -4]);

    // transform light position
    vec3.set(lightPosition, 0.0, 0.0, 0.0);
    vec3.transformMat4(lightPosition, lightPosition, lightMatrix);

    gl.uniform3fv(lightPositionLocation, lightPosition);

    // spot light points to the sphere position
    vec3.sub(spotDirection, spherePosition, lightPosition);
    gl.uniform3fv(lightSpotDirectionLocation, spotDirection);

    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}
</script>
</body>
</html>