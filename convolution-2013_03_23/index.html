<!DOCTYPE html>
<html>
<head>
<title>texture</title>
<script src="../lib/gl-matrix.js"></script>
<script src="../lib/utils.js"></script>

<script id='vshader' type="x-shader/x-vertex">
attribute vec3 a_position;

uniform mat4 u_pMatrix;

attribute vec2 a_texCoord;
varying vec2 v_texCoord;

void main(){
  // pass to fragment shader
  v_texCoord = a_texCoord;
  gl_Position = u_pMatrix * vec4(a_position, 1);
}
</script>


<script id='fshader' type="x-shader/x-fragment">
precision mediump float;

// textures
uniform sampler2D u_image0;
uniform vec2 u_textureSize;
uniform float u_kernel[9];

// texture coordinate passed from vertex shader
varying vec2 v_texCoord;

void main(){
  // texture coordinate is in the range of [0, 1], e.g., texture width is 1024, in order
  // to shift 1 pixel in horizontal, the shift value will be: 1/1024.
  vec2 pixel = vec2(1, 1) / u_textureSize;

  vec4 colorSum = texture2D(u_image0, v_texCoord + pixel * vec2(-1, -1)) * u_kernel[0] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2( 0, -1)) * u_kernel[1] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2( 1, -1)) * u_kernel[2] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2(-1,  0)) * u_kernel[3] +
                  texture2D(u_image0, v_texCoord + pixel * vec2( 0,  0)) * u_kernel[4] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2( 1,  0)) * u_kernel[5] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2(-1,  1)) * u_kernel[6] + 
                  texture2D(u_image0, v_texCoord + pixel * vec2( 0,  1)) * u_kernel[7] +  
                  texture2D(u_image0, v_texCoord + pixel * vec2( 1,  1)) * u_kernel[8];
  float kernelWeight = u_kernel[0] + u_kernel[1] + u_kernel[2] + 
                       u_kernel[3] + u_kernel[4] + u_kernel[5] +
                       u_kernel[6] + u_kernel[7] + u_kernel[8];

  if(kernelWeight <= 0.0) kernelWeight = 1.0;

  gl_FragColor = vec4((colorSum / kernelWeight).rgb, 1.0);
  // gl_FragColor = texture2D(u_image0, v_texCoord);
}
</script>
</head>
<body>

<canvas id='canvas' width='800' height='600'></canvas>

<script>
// var kernel = [
//   1, 1, 1,
//   1,  1, 1,
//   1, 1, 1
// ];
var kernel = [
   0,  1,  0,
   1, -4,  1,
   0,  1,  0
];
var canvas = document.getElementById('canvas');
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.clearColor(0,0,0,1);
gl.clear(gl.COLOR_BUFFER_BIT);


// create shaders and program
var vshader = compileShader(gl, document.getElementById('vshader').textContent, gl.VERTEX_SHADER);
var fshader = compileShader(gl, document.getElementById('fshader').textContent, gl.FRAGMENT_SHADER);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

// get the information store them in the variable
var positionLocation = gl.getAttribLocation(program, 'a_position');
var pMatrixLocation = gl.getUniformLocation(program, 'u_pMatrix');
var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
var texSizeLocation = gl.getUniformLocation(program, 'u_textureSize');
var kernelLocation = gl.getUniformLocation(program, 'u_kernel[0]');


function render(images){
  // update uniform texture size
  gl.uniform2f(texSizeLocation, images[0].width, images[0].height);

  // texture buffer object
  var tbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    1, 0,
    0, 0,
    1, 1,
    0, 1
    ]), gl.STATIC_DRAW);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(texCoordLocation);
  // create texture
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // set parameters
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  // upload texture data
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[0]);


  var vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  // upload data
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    images[0].width,  0,                  0,
    0,                0,                  0,
    images[0].width,  images[0].height,   0,
    0,                images[0].height,   0
    ]), gl.STATIC_DRAW);
  // describe the vertices data structure
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
  // use array to draw vertex
  gl.enableVertexAttribArray(positionLocation);
  // setup orth projection matrix, the transpose has to be set to false, for now... seems like it is not implemented yet.
  gl.uniformMatrix4fv(pMatrixLocation, false, [
    2/canvas.width, 0,                0,       0,
    0,             -2/canvas.height,  0,        0,
    0,              0,                2/200,   0,
    -1,             1,                1,        1
  ]);
  // set kernel
  gl.uniform1fv(kernelLocation, kernel);

  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}


loadImages(['../img/riceballs.png'], render);

</script>

</body>
</html>
























