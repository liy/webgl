<!DOCTYPE html>
<html>
<head>
<title></title>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script type="x-shader/x-vertex" id='vshader'>
attribute vec3 a_Position;
attribute vec3 a_Normal;
attribute vec2 a_TexCoord;

uniform mat4 u_ModelViewMatrix;
uniform mat4 u_ProjectionMatrix;

// the inverse transpose of model view matrix for normal transformation
uniform mat3 u_NormalMatrix;

varying vec4 v_Position;
varying vec3 v_Normal;
varying vec2 v_TexCoord;

void main(){
  v_Position = u_ModelViewMatrix * vec4(a_Position, 1.0);
  gl_Position = u_ProjectionMatrix * v_Position;

  v_Normal = u_NormalMatrix * a_Normal;
  v_TexCoord = a_TexCoord;
}
</script>
<script type="x-shader/x-fragment" id='fshader'>
precision mediump float;

// linear interpolate the normal, note that this normal is transformed, but not normalized.
varying vec3 v_Normal;
varying vec2 v_TexCoord;
varying vec4 v_Position;

// texture sampler
uniform sampler2D u_Sampler;

// ambient light color
uniform vec4 u_AmbientColor;

// light source position
uniform vec3 u_LightPosition;
// diffuse color 
uniform vec4 u_DiffuseColor;
// TODO: specular light color

void main(){
  vec3 lightDirection = normalize(u_LightPosition - v_Position.xyz);
  vec4 lightWeight = u_AmbientColor + u_DiffuseColor * max(dot(normalize(v_Normal), lightDirection), 0.0);

  vec4 color = texture2D(u_Sampler, v_TexCoord);
  gl_FragColor = vec4(color.rgb * lightWeight.rgb, color.a * lightWeight.a);
}

</script>
</head>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
// gl.enable(gl.BLEND);
// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
// gl.enable(gl.CULL_FACE);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var vshader = compileShader(gl, document.getElementById('vshader').textContent, gl.VERTEX_SHADER);
var fshader = compileShader(gl, document.getElementById('fshader').textContent, gl.FRAGMENT_SHADER);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

// vertex shader attributes
var positionLocation = gl.getAttribLocation(program, 'a_Position');
var normalLocation = gl.getAttribLocation(program, 'a_Normal');
var texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
// vertex shader uniforms
var modelViewMatrixLocation = gl.getUniformLocation(program, 'u_ModelViewMatrix');
var projectionMatrixLocation = gl.getUniformLocation(program, 'u_ProjectionMatrix');
var normalMatrixLocation = gl.getUniformLocation(program, 'u_NormalMatrix');
// fragment shader uniforms
var ambientColorLocation = gl.getUniformLocation(program, 'u_AmbientColor');
var lightPositionLocation = gl.getUniformLocation(program, 'u_LightPosition');
var diffuseColorLocation = gl.getUniformLocation(program, 'u_DiffuseColor');

// geometry
var vertices = [
  // front
  -0.5, -0.5,  0.5,
   0.5, -0.5,  0.5,
   0.5,  0.5,  0.5,
  -0.5,  0.5,  0.5,
  // back
   0.5, -0.5, -0.5,
  -0.5, -0.5, -0.5,
  -0.5,  0.5, -0.5,
   0.5,  0.5, -0.5,
  // top
  -0.5,  0.5,  0.5,
   0.5,  0.5,  0.5,
   0.5,  0.5, -0.5,
  -0.5,  0.5, -0.5, 
  // bottom
  -0.5, -0.5, -0.5,
   0.5, -0.5, -0.5,
   0.5, -0.5,  0.5,
  -0.5, -0.5,  0.5,
  // left
  -0.5, -0.5, -0.5,
  -0.5, -0.5,  0.5,
  -0.5,  0.5,  0.5,
  -0.5,  0.5, -0.5,
  // right
   0.5, -0.5,  0.5,
   0.5, -0.5, -0.5,
   0.5,  0.5, -0.5,
   0.5,  0.5,  0.5
];

var texCoord = [
  // y flipped
  // front
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0,
  // back
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0,
  // top
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0,
  // bottom
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0,
  // left
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0,
  // right
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
  0.0, 0.0
];

var indices = [
  0,  1,  2,   0,  2,  3,  // front
  4,  5,  6,   4,  6,  7,  // back
  8,  9,  10,  8,  10, 11, // top
  12, 13, 14,  12, 14, 15, // bottom
  16, 17, 18,  16, 18, 19, // left
  20, 21, 22,  20, 22, 23  // right
];

var normals = [
  // front
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
   0.0,  0.0,  1.0,
  // back
   0.0,  0.0, -1.0,
   0.0,  0.0, -1.0,
   0.0,  0.0, -1.0,
   0.0,  0.0, -1.0,
  // top
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0,
   0.0,  1.0,  0.0, 
  // bottom
   0.0, -1.0,  0.0,
   0.0, -1.0,  0.0,
   0.0, -1.0,  0.0,
   0.0, -1.0,  0.0,
  // left
  -1.0,  0.0,  0.0,
  -1.0,  0.0,  0.0,
  -1.0,  0.0,  0.0,
  -1.0,  0.0,  0.0,
  // right
   1.0,  0.0,  0.0,
   1.0,  0.0,  0.0,
   1.0,  0.0,  0.0,
   1.0,  0.0,  0.0
];

// setup lighting
gl.uniform4fv(ambientColorLocation, [0.2, 0.2, 0.2, 1.0]);
gl.uniform4fv(diffuseColorLocation, [0.9, 0.9, 0.9, 1.0]);
gl.uniform3fv(lightPositionLocation, [0.0, 0.0, -4.3]);

// setup projection
var projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, Math.PI/3, canvas.width/canvas.height, 0.1, 800);
gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

// model view
var modelViewMatrix = mat4.create();

// normal matrix
var normalMatrix = mat3.create();

// other variables
var rotationX = 0;
var rotationY = 0;

var image = createImage('../img/block.png', init);
function init(){
  // buffers
  var vb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  var nb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, nb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(normalLocation);

  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  var tb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoord), gl.STATIC_DRAW);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(texCoordLocation);
  
  var ib = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

  function render(){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // update model view matrix
    rotationX += 0.01;
    rotationY += 0.02;
    mat4.identity(modelViewMatrix);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -5]);
    mat4.rotate(modelViewMatrix, modelViewMatrix, rotationX, [1, 0, 0]);
    mat4.rotate(modelViewMatrix, modelViewMatrix, rotationY, [0, 1, 0]);
    // mat4.scale(modelViewMatrix, modelViewMatrix, [10, 10, 10])
    gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

    // update normal use inverse transpose of model view matrix
    mat3.normalFromMat4(normalMatrix, modelViewMatrix);
    gl.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix);

    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    
    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}

</script>
</body>
</html>