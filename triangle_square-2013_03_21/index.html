<!DOCTYPE html>
<html>
<head>
<title></title>
<script src="../lib/gl-matrix.js"></script>
</head>
<body>
<canvas id="wu" style="border: none;" width="640" height="640"></canvas>

<script id="vshader" type="x-shader/x-fragment">
  attribute vec3 aVertexPosition;

  uniform mat4 uPMatrix;
  uniform mat4 uMVMatrix;

  void main() {
    gl_Position =  uPMatrix * uMVMatrix * vec4(aVertexPosition, 1);
  }
</script>

<script id="fshader" type="x-shader/x-fragment">
  void main() {
    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
  }
</script>

<script>

var canvas, gl;

var triangleVertexPositionBuffer, squareVertexPositionBuffer;

// projection matrix
var pMatrix = mat4.create();
// model view matrix
var mvMatrix = mat4.create();

var shaderProgram;

function initWebGL(){
  canvas = document.getElementById('wu');
  gl = canvas.getContext('experimental-webgl') || canvas.getContext('webgl');

  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

}

function createShader(type, source){
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw gl.getShaderInfoLog(shader);
  }

  return shader;
}

function createProgram(vsource, fsource){
  var program = gl.createProgram();
  var vshader = createShader(gl.VERTEX_SHADER, vsource);
  var fshader = createShader(gl.FRAGMENT_SHADER, fsource);
  gl.attachShader(program, vshader);
  gl.attachShader(program, fshader);

  gl.linkProgram(program);


  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw gl.getProgramInfoLog(program);
  }

  return program;
}

function initShaders(){
  var vs = document.getElementById('vshader').textContent;
  var fs = document.getElementById('fshader').textContent;

  shaderProgram = createProgram(vs, fs);

  // use the shader program
  gl.useProgram(shaderProgram);

  // get the vertex shader input attribute variable memory location, so we could link javascript vertice data to it.
  shaderProgram.vertexAttribPointer = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
  // tell WebGL that we will want to provide values for the input attribute using an array, of cource, the vertices position information will be array.
  gl.enableVertexAttribArray(shaderProgram.vertexAttribPointer);

  // get the memory location of the input projection and model matrix uniforms
  shaderProgram.pMatrixUnifPointer = gl.getUniformLocation(shaderProgram, 'uPMatrix');
  shaderProgram.mvMatrixUnifPointer = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
}

function setMatrixUniforms(){
  gl.uniformMatrix4fv(shaderProgram.pMatrixUnifPointer, false, pMatrix);
  gl.uniformMatrix4fv(shaderProgram.mvMatrixUnifPointer, false, mvMatrix);
}

function initBuffer(){
  // start initializing triangle buffer
  // create buffer to hold the vertex position for triangle
  triangleVertexPositionBuffer = gl.createBuffer();
  // bind the triangle buffer, any following operation will apply to this buffer object.
  gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
  // create triangle vertex positions
  var vertices = [
     0.0,  1.0,  0.0,
    -1.0, -1.0,  0.0,
     1.0, -1.0,  0.0
  ];
  // upload the vertices to the buffer object, but not drawing yet.
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  // 3 vertex, triangle
  triangleVertexPositionBuffer.numItems = 3;
  // 3 components per vertex: x, y and z
  triangleVertexPositionBuffer.itemSize = 3;

  // initialize square buffer
  squareVertexPositionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
  vertices = [
     1.0,  1.0, 0.0,
    -1.0,  1.0, 0.0,
     1.0, -1.0, 0.0,
    -1.0, -1.0, 0.0
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  squareVertexPositionBuffer.numItems = 4;
  squareVertexPositionBuffer.itemSize = 3;
}

function drawScene(){
  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // setup projection, could be move outside to init function and resize function
  mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
  
  // draw triangle
  mat4.identity(mvMatrix);
  // translate triangle to the left
  mat4.translate(mvMatrix, mvMatrix, [-1.5, 0.0, -7.0]);
  // draw triangle
  gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
  // tell webgl how to draw: 3 components per vertex
  gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
  // move javascript matrix to the webgl
  setMatrixUniforms();
  // draw 3 vertices, which are in the bind buffer
  gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);

  // draw square, move square related to the triangle, move 3 unit right
  mat4.translate(mvMatrix, mvMatrix, [3.0, 0.0, 0.0]);
  gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
  gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
  // move javascript matrix to the webgl
  setMatrixUniforms();
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
}

initWebGL();
initBuffer();
initShaders();
drawScene();


// error handling
window.onerror = function(msg, url, lineno) {
  alert(url + '(' + lineno + '): ' + msg);
}

</script>

</body>
</html>