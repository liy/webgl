<!DOCTYPE html>
<html>
<head>
<title>specular</title>
</head>
<script src='../lib/gl-matrix.js'></script>
<script src='../lib/utils.js'></script>
<script type="x-shader/x-vertex" id='vshader'>
attribute vec3 a_Position;
attribute vec3 a_Normal;
attribute vec2 a_TexCoord;

uniform mat4 u_ProjectionMatrix;
uniform mat4 u_ModelViewMatrix;
uniform mat3 u_NormalMatrix;

// vertex position will be transformed into world coordinate, interpolate and pass to fragment shader, in order to calculate light direction
varying vec4 v_Position;
varying vec2 v_TexCoord;
// transformed normal, interpolated and pass to the fragment shader, remember to normalize it.
varying vec3 v_Normal;

void main(){
  // interpolate the position
  v_Position = u_ModelViewMatrix * vec4(a_Position, 1.0);
  gl_Position = u_ProjectionMatrix * v_Position;
  v_Normal = u_NormalMatrix * a_Normal;
  v_TexCoord = a_TexCoord;
}

</script>
<script type="x-shader/x-fragment" id='fshader'>
precision mediump float;
// this position is actually fragment position, since it is interpolated between vertices.
varying vec4 v_Position;
// texture coordinate
varying vec2 v_TexCoord;
// the transformed normal, note that because it is interpolated, it is not normalized
varying vec3 v_Normal;

uniform sampler2D u_Sampler;

// light position in world coordinate
uniform vec3 u_LightPosition;
uniform vec4 u_AmbientColor;
uniform vec4 u_DiffuseColor;
// specular
uniform vec4 u_SpecularColor;

void main(){
  vec3 normalizedNormal = normalize(v_Normal);
  vec3 lightDirection = normalize(u_LightPosition - v_Position.xyz);
  
  vec3 eyeDirection = normalize(-v_Position.xyz);
  vec3 reflectionDirection = reflect(-lightDirection, normalizedNormal);

  float diffuseWeight = max(dot(normalizedNormal, lightDirection), 0.0);
  float specularWeight = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 45.0);

  vec4 lightWeight = u_AmbientColor + u_DiffuseColor * diffuseWeight + u_SpecularColor * specularWeight;
  vec4 color = texture2D(u_Sampler, v_TexCoord);
  gl_FragColor = vec4(color.rgb * lightWeight.rgb, color.a);
}

</script>
<body style="margin:0">
<canvas id='canvas'></canvas>
<script>
var canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

var vshader = compileShader(gl, document.getElementById('vshader').textContent, gl.VERTEX_SHADER);
var fshader = compileShader(gl, document.getElementById('fshader').textContent, gl.FRAGMENT_SHADER);
var program = createProgram(gl, vshader, fshader);
gl.useProgram(program);

var positionLocation = gl.getAttribLocation(program, 'a_Position');
var normalLocation = gl.getAttribLocation(program, 'a_Normal');
var texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
var projectionMatrixLocation = gl.getUniformLocation(program, 'u_ProjectionMatrix');
var modelViewMatrixLocation = gl.getUniformLocation(program, 'u_ModelViewMatrix');
var normalMatrixLocation = gl.getUniformLocation(program, 'u_NormalMatrix');
var lightPositionLocation = gl.getUniformLocation(program, 'u_LightPosition');
var ambientColorLocation = gl.getUniformLocation(program, 'u_AmbientColor');
var diffuseColorLocation = gl.getUniformLocation(program, 'u_DiffuseColor');
var specularColorLocation = gl.getUniformLocation(program, 'u_SpecularColor');

// variables
var vertices = [];
var indices = [];
var texCoord = [];
var normals = [];

// sphere
var axialTilt = -23.439 * Math.PI/180;
var latitudeBands = 30;
var longitudeBands = 30;
var radius = 0.6;
var theta = Math.PI/2;
var phi = Math.PI/2;
var x = 0;
var y = 0;
var z = 0;
for(var i=0; i<=latitudeBands; ++i){
  theta = Math.PI/2 - i * (Math.PI/latitudeBands);
  cosTheta = Math.cos(theta);
  sinTheta = Math.sin(theta);
  for(var j=0; j<=longitudeBands; ++j){
    phi = j * (Math.PI*2 / longitudeBands);
    
    x = cosTheta * Math.cos(phi);
    y = sinTheta;
    z = cosTheta * Math.sin(phi);

    // normals
    normals.push(x);
    normals.push(y);
    normals.push(z);

    vertices.push(x * radius);
    vertices.push(y * radius);
    vertices.push(z * radius);

    texCoord.push(1 - j/longitudeBands);
    texCoord.push(i/latitudeBands);
  }
}
// indices
for(var i=0; i<latitudeBands; ++i){
  for(var j=0; j<longitudeBands; ++j){
    var topLeft = i * longitudeBands + i + j;
    var bottomLeft = topLeft + longitudeBands + 1;

    indices.push(topLeft);
    indices.push(bottomLeft);
    indices.push(bottomLeft + 1);
    indices.push(bottomLeft + 1);
    indices.push(topLeft + 1);
    indices.push(topLeft);
  }
}

// matrices
var projectionMatrix = mat4.create();
mat4.perspective(projectionMatrix, Math.PI/3, canvas.width/canvas.height, 0.1, 1000);
var modelViewMatrix = mat4.create();
var normalMatrix = mat3.create();

// pre-set uniforms
gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);

// specular color
var specularColor = [1.8, 1.8, 1.8, 0.0];
gl.uniform4fv(specularColorLocation, specularColor);
// ambient color 
var ambientColor = [0.05, 0.05, 0.05, 1.0];
gl.uniform4fv(ambientColorLocation, ambientColor);
// directional light
var diffuseColor = [2.0, 2.0, 2.0, 1.0];
gl.uniform4fv(diffuseColorLocation, diffuseColor);
// directional light direction
var lightPosition = [0.0, 0.0, -3.8];
gl.uniform3fv(lightPositionLocation, lightPosition);



// buffers
var vb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(positionLocation);

var ib = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

var tb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, tb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoord), gl.STATIC_DRAW);
gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(texCoordLocation);

var nb = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, nb);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(normalLocation);

var rotationY = -Math.PI/2;
// create image, texture and render
var image = createImage('../img/earth-big.jpg', init);
function init(){
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.generateMipmap(gl.TEXTURE_2D);

  function render(){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    cameraRotationX += (cameraTargetRotationX - cameraRotationX)/10;
    cameraRotationY += (cameraTargetRotationY - cameraRotationY)/10;


    rotationY += 0.01;

    var tx = -4.0;
    var ty = 10.0;
    for(var i=0; i<250; ++i){
      mat4.identity(modelViewMatrix);


    mat4.rotate(modelViewMatrix, modelViewMatrix, cameraRotationY, [0, 1, 0]);
    mat4.rotate(modelViewMatrix, modelViewMatrix, cameraRotationX, [1, 0, 0]);


      mat4.translate(modelViewMatrix, modelViewMatrix, [tx, ty, -5.0]);
      mat4.rotateZ(modelViewMatrix, modelViewMatrix, axialTilt);
      mat4.rotateY(modelViewMatrix, modelViewMatrix, rotationY);
      
      gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

      // update inverse model view matrix
      mat3.normalFromMat4(normalMatrix, modelViewMatrix);
      gl.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix);

      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      tx += 1.5;
      if(tx >= 5)
      {
        tx = -4.0;
        ty -= 1.5;
      }
    }

    requestAnimFrame(render);
  }
  requestAnimFrame(render);
}

var cameraTargetRotationY = 0;
var cameraTargetRotationX = 0;
var cameraRotationX = 0;
var cameraRotationY = 0;
document.onmousemove = function(evt){
  cameraTargetRotationX = -evt.y/window.innerHeight * Math.PI*2;
  cameraTargetRotationY = evt.x/window.innerWidth * Math.PI*2;
}




</script>
</body>
</html>